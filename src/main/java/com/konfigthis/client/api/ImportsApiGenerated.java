/*
 * Timmi Absences API
 * Welcome on the documentation for Timmi Absences API.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: developers@lucca.fr
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.ImportsAbsenceBatchCreateResponse;
import com.konfigthis.client.model.ImportsCreateAbsencesBatchRequest;
import com.konfigthis.client.model.ImportsCreateAbsencesBatchResponse;
import com.konfigthis.client.model.ImportsEntitlementsBatchImportRequest;
import com.konfigthis.client.model.ImportsEntitlementsBatchImportResponse;
import com.konfigthis.client.model.ImportsImportLeaveEntitlementsRequest;
import com.konfigthis.client.model.ImportsReplaceEntitlementsRequest;
import com.konfigthis.client.model.ImportsReplaceEntitlementsRequest1;
import java.time.OffsetDateTime;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class ImportsApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ImportsApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public ImportsApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        if (apiClient.getAuthorization() == null) {
            throw new IllegalArgumentException("\"Authorization\" is required but no API key was provided. Please set \"Authorization\" with ApiClient#setAuthorization(String).");
        }
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call absenceBatchCreateCall(String type, String originalFileName, Boolean create, Boolean recredit, Boolean synchronize, Boolean overrideLeaves, Object body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/v3/services/importLeavePeriods";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        if (create != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("create", create));
        }

        if (recredit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recredit", recredit));
        }

        if (originalFileName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("originalFileName", originalFileName));
        }

        if (synchronize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("synchronize", synchronize));
        }

        if (overrideLeaves != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("overrideLeaves", overrideLeaves));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call absenceBatchCreateValidateBeforeCall(String type, String originalFileName, Boolean create, Boolean recredit, Boolean synchronize, Boolean overrideLeaves, Object body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'type' is set
        if (type == null) {
            throw new ApiException("Missing the required parameter 'type' when calling absenceBatchCreate(Async)");
        }

        // verify the required parameter 'originalFileName' is set
        if (originalFileName == null) {
            throw new ApiException("Missing the required parameter 'originalFileName' when calling absenceBatchCreate(Async)");
        }

        return absenceBatchCreateCall(type, originalFileName, create, recredit, synchronize, overrideLeaves, body, _callback);

    }


    private ApiResponse<ImportsAbsenceBatchCreateResponse> absenceBatchCreateWithHttpInfo(String type, String originalFileName, Boolean create, Boolean recredit, Boolean synchronize, Boolean overrideLeaves, Object body) throws ApiException {
        okhttp3.Call localVarCall = absenceBatchCreateValidateBeforeCall(type, originalFileName, create, recredit, synchronize, overrideLeaves, body, null);
        Type localVarReturnType = new TypeToken<ImportsAbsenceBatchCreateResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call absenceBatchCreateAsync(String type, String originalFileName, Boolean create, Boolean recredit, Boolean synchronize, Boolean overrideLeaves, Object body, final ApiCallback<ImportsAbsenceBatchCreateResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = absenceBatchCreateValidateBeforeCall(type, originalFileName, create, recredit, synchronize, overrideLeaves, body, _callback);
        Type localVarReturnType = new TypeToken<ImportsAbsenceBatchCreateResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class AbsenceBatchCreateRequestBuilder {
        private final String type;
        private final String originalFileName;
        private Boolean create;
        private Boolean recredit;
        private Boolean synchronize;
        private Boolean overrideLeaves;

        private AbsenceBatchCreateRequestBuilder(String type, String originalFileName) {
            this.type = type;
            this.originalFileName = originalFileName;
        }

        /**
         * Set create
         * @param create Use &#x60;false&#x60; to simulate the import. (optional, default to false)
         * @return AbsenceBatchCreateRequestBuilder
         */
        public AbsenceBatchCreateRequestBuilder create(Boolean create) {
            this.create = create;
            return this;
        }
        
        /**
         * Set recredit
         * @param recredit Use &#x60;true&#x60; if absences should **not** be deducted from the user balance. Use &#x60;false&#x60; if absences should be deducted from the user balance. Note: if the absence type doesn’t have balance management, absence won’t impact the balance in any case. (optional)
         * @return AbsenceBatchCreateRequestBuilder
         */
        public AbsenceBatchCreateRequestBuilder recredit(Boolean recredit) {
            this.recredit = recredit;
            return this;
        }
        
        /**
         * Set synchronize
         * @param synchronize Use &#x60;true&#x60; to force synchronization of the absences in the sync webservice (sync to Exchange/0365, Google Calendar, Webhook or ADP GXP, depending on configuration). Use &#x60;false&#x60; to import absences without synchronizing absences. (optional)
         * @return AbsenceBatchCreateRequestBuilder
         */
        public AbsenceBatchCreateRequestBuilder synchronize(Boolean synchronize) {
            this.synchronize = synchronize;
            return this;
        }
        
        /**
         * Set overrideLeaves
         * @param overrideLeaves Use &#x60;true&#x60; to allow replacing existing absences (optional)
         * @return AbsenceBatchCreateRequestBuilder
         */
        public AbsenceBatchCreateRequestBuilder overrideLeaves(Boolean overrideLeaves) {
            this.overrideLeaves = overrideLeaves;
            return this;
        }
        
        /**
         * Build call for absenceBatchCreate
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            Object body = buildBodyParams();
            return absenceBatchCreateCall(type, originalFileName, create, recredit, synchronize, overrideLeaves, body, _callback);
        }

        private Object buildBodyParams() {
            Object body = new Object();
            return body;
        }

        /**
         * Execute absenceBatchCreate request
         * @return ImportsAbsenceBatchCreateResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ImportsAbsenceBatchCreateResponse execute() throws ApiException {
            Object body = buildBodyParams();
            ApiResponse<ImportsAbsenceBatchCreateResponse> localVarResp = absenceBatchCreateWithHttpInfo(type, originalFileName, create, recredit, synchronize, overrideLeaves, body);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute absenceBatchCreate request with HTTP info returned
         * @return ApiResponse&lt;ImportsAbsenceBatchCreateResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<ImportsAbsenceBatchCreateResponse> executeWithHttpInfo() throws ApiException {
            Object body = buildBodyParams();
            return absenceBatchCreateWithHttpInfo(type, originalFileName, create, recredit, synchronize, overrideLeaves, body);
        }

        /**
         * Execute absenceBatchCreate request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<ImportsAbsenceBatchCreateResponse> _callback) throws ApiException {
            Object body = buildBodyParams();
            return absenceBatchCreateAsync(type, originalFileName, create, recredit, synchronize, overrideLeaves, body, _callback);
        }
    }

    /**
     * Import leaves (deprecated)
     * Create absences in batch from a CSV file.  **Important notice: Absence imports cannot be cancelled.**   In case of a mistake absences must be deleted manually through the interface or using the API (see Use cases). **Use import with care!**   **File format**  Type: CSV (with semicolon \&quot;;\&quot;)  Encoding: UTF-8   All the following fields must be present with the field name in the header:  - legalEntity : establishment of the employee - employeeNumber : employee number - lastName : last name of the employee - firstName : firstname of the employee - accountId : absence account id in Timmi Absences (you can find it in the leave accounts admin page) - startDate : absence start date (DD/MM/YYYY) - flagStartDate : AM (if the absences starts in the morning) or PM (if the absence starts in the afternoon) - endDate : absence end date (DD/MM/YYYY) - flagEndDate : AM (if the absences ends at noon) or PM (if the absences ends in the afternoon) - isApproved : yes or no. Compulsory if the absence type is subject to approval, optional otherwise.  **History** Import history is available in the import module, including imports made using the API. 
     * @param type Support CSV files only (required)
     * @param originalFileName Filename (required)
     * @return AbsenceBatchCreateRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public AbsenceBatchCreateRequestBuilder absenceBatchCreate(String type, String originalFileName) throws IllegalArgumentException {
        if (type == null) throw new IllegalArgumentException("\"type\" is required but got null");
            

        if (originalFileName == null) throw new IllegalArgumentException("\"originalFileName\" is required but got null");
            

        return new AbsenceBatchCreateRequestBuilder(type, originalFileName);
    }
    private okhttp3.Call createAbsencesBatchCall(Boolean create, Boolean recredit, String originalFileName, Boolean synchronize, Boolean async, List<String> files, ImportsCreateAbsencesBatchRequest importsCreateAbsencesBatchRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = importsCreateAbsencesBatchRequest;

        // create path and map variables
        String localVarPath = "/timmi-absences/api/imports/v1.0/leavePeriods";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (files != null) {
            localVarFormParams.put("files", files);
        }

        if (create != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("create", create));
        }

        if (recredit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recredit", recredit));
        }

        if (originalFileName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("originalFileName", originalFileName));
        }

        if (synchronize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("synchronize", synchronize));
        }

        if (async != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("async", async));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createAbsencesBatchValidateBeforeCall(Boolean create, Boolean recredit, String originalFileName, Boolean synchronize, Boolean async, List<String> files, ImportsCreateAbsencesBatchRequest importsCreateAbsencesBatchRequest, final ApiCallback _callback) throws ApiException {
        return createAbsencesBatchCall(create, recredit, originalFileName, synchronize, async, files, importsCreateAbsencesBatchRequest, _callback);

    }


    private ApiResponse<ImportsCreateAbsencesBatchResponse> createAbsencesBatchWithHttpInfo(Boolean create, Boolean recredit, String originalFileName, Boolean synchronize, Boolean async, List<String> files, ImportsCreateAbsencesBatchRequest importsCreateAbsencesBatchRequest) throws ApiException {
        okhttp3.Call localVarCall = createAbsencesBatchValidateBeforeCall(create, recredit, originalFileName, synchronize, async, files, importsCreateAbsencesBatchRequest, null);
        Type localVarReturnType = new TypeToken<ImportsCreateAbsencesBatchResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createAbsencesBatchAsync(Boolean create, Boolean recredit, String originalFileName, Boolean synchronize, Boolean async, List<String> files, ImportsCreateAbsencesBatchRequest importsCreateAbsencesBatchRequest, final ApiCallback<ImportsCreateAbsencesBatchResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createAbsencesBatchValidateBeforeCall(create, recredit, originalFileName, synchronize, async, files, importsCreateAbsencesBatchRequest, _callback);
        Type localVarReturnType = new TypeToken<ImportsCreateAbsencesBatchResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateAbsencesBatchRequestBuilder {
        private Boolean create;
        private Boolean recredit;
        private String originalFileName;
        private Boolean synchronize;
        private Boolean async;
        private List<String> files;

        private CreateAbsencesBatchRequestBuilder() {
        }

        /**
         * Set create
         * @param create Use &#x60;false&#x60; to simulate the import. (optional)
         * @return CreateAbsencesBatchRequestBuilder
         */
        public CreateAbsencesBatchRequestBuilder create(Boolean create) {
            this.create = create;
            return this;
        }
        
        /**
         * Set recredit
         * @param recredit Use &#x60;true&#x60; if absences should **not** be deducted from the user balance. Use &#x60;false&#x60; if absences should be deducted from the user balance. Note: if the absence type doesn’t have balance management, absence won’t impact the balance in any case. (optional)
         * @return CreateAbsencesBatchRequestBuilder
         */
        public CreateAbsencesBatchRequestBuilder recredit(Boolean recredit) {
            this.recredit = recredit;
            return this;
        }
        
        /**
         * Set originalFileName
         * @param originalFileName Filename (optional, default to import.csv)
         * @return CreateAbsencesBatchRequestBuilder
         */
        public CreateAbsencesBatchRequestBuilder originalFileName(String originalFileName) {
            this.originalFileName = originalFileName;
            return this;
        }
        
        /**
         * Set synchronize
         * @param synchronize Use &#x60;true&#x60; to force synchronization of the absences in the sync webservice (sync to Exchange/0365, Google Calendar, Webhook or ADP GXP, depending on configuration). Use &#x60;false&#x60; to import absences without synchronizing absences. (optional)
         * @return CreateAbsencesBatchRequestBuilder
         */
        public CreateAbsencesBatchRequestBuilder synchronize(Boolean synchronize) {
            this.synchronize = synchronize;
            return this;
        }
        
        /**
         * Set async
         * @param async Use &#x60;true&#x60; if you want to import absences with the asynchronous processing (you have to request figgo/api/imports/v1.0/leavePeriods/{summaryId}/progress API to track the status). Use &#x60;false&#x60; if you want import absences with the synchronous processing (the response is sent when the file is fully imported). (optional)
         * @return CreateAbsencesBatchRequestBuilder
         */
        public CreateAbsencesBatchRequestBuilder async(Boolean async) {
            this.async = async;
            return this;
        }
        
        /**
         * Set files
         * @param files  (optional)
         * @return CreateAbsencesBatchRequestBuilder
         */
        public CreateAbsencesBatchRequestBuilder files(List<String> files) {
            this.files = files;
            return this;
        }
        
        /**
         * Build call for createAbsencesBatch
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ImportsCreateAbsencesBatchRequest importsCreateAbsencesBatchRequest = buildBodyParams();
            return createAbsencesBatchCall(create, recredit, originalFileName, synchronize, async, files, importsCreateAbsencesBatchRequest, _callback);
        }

        private ImportsCreateAbsencesBatchRequest buildBodyParams() {
            ImportsCreateAbsencesBatchRequest importsCreateAbsencesBatchRequest = new ImportsCreateAbsencesBatchRequest();
            importsCreateAbsencesBatchRequest.files(this.files);
            return importsCreateAbsencesBatchRequest;
        }

        /**
         * Execute createAbsencesBatch request
         * @return ImportsCreateAbsencesBatchResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ImportsCreateAbsencesBatchResponse execute() throws ApiException {
            ImportsCreateAbsencesBatchRequest importsCreateAbsencesBatchRequest = buildBodyParams();
            ApiResponse<ImportsCreateAbsencesBatchResponse> localVarResp = createAbsencesBatchWithHttpInfo(create, recredit, originalFileName, synchronize, async, files, importsCreateAbsencesBatchRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createAbsencesBatch request with HTTP info returned
         * @return ApiResponse&lt;ImportsCreateAbsencesBatchResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ImportsCreateAbsencesBatchResponse> executeWithHttpInfo() throws ApiException {
            ImportsCreateAbsencesBatchRequest importsCreateAbsencesBatchRequest = buildBodyParams();
            return createAbsencesBatchWithHttpInfo(create, recredit, originalFileName, synchronize, async, files, importsCreateAbsencesBatchRequest);
        }

        /**
         * Execute createAbsencesBatch request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ImportsCreateAbsencesBatchResponse> _callback) throws ApiException {
            ImportsCreateAbsencesBatchRequest importsCreateAbsencesBatchRequest = buildBodyParams();
            return createAbsencesBatchAsync(create, recredit, originalFileName, synchronize, async, files, importsCreateAbsencesBatchRequest, _callback);
        }
    }

    /**
     * Import leaves
     * Create absences in batch from a CSV file.  **Important notice: Absence imports cannot be cancelled.**   In case of a mistake absences must be deleted manually through the interface or using the API (see Use cases). **Use import with care!**  **File format**  Content-Type: CSV. Column divider is semicolon \&quot;;\&quot;. Line breaks between rows.  Encoding: UTF-8  All the following fields must be present with the field name in the header:  - legalEntity: Name of the establishment the employee belongs to. - employeeNumber: Employee number. - lastName: Family (last) name of the employee. - firstName: Given (first) name of the employee. - accountId: Identifier of the absence account in Timmi Absences (can be found in the leave accounts admin page). - startDate: Start date of the absence, formatted as &#x60;DD/MM/YYYY&#x60;. - flagStartDate: &#x60;\&quot;AM\&quot;&#x60; if the absence starts in the morning or &#x60;\&quot;PM\&quot;&#x60; if the absence starts in the afternoon. - endDate: End date of the absence, formatted as &#x60;DD/MM/YYYY&#x60;. - flagEndDate: &#x60;\&quot;AM\&quot;&#x60; if the absence ends at noon or &#x60;\&quot;PM\&quot;&#x60; if the absence ends in the afternoon. - isApproved: &#x60;true&#x60; or &#x60;false&#x60;. Dictates whether the absence request should be created and already approved.    Required if the type of the absence requires approval, optional otherwise.  **History** Import history is available in the import module. It includes imports made via the API. 
     * @return CreateAbsencesBatchRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public CreateAbsencesBatchRequestBuilder createAbsencesBatch() throws IllegalArgumentException {
        return new CreateAbsencesBatchRequestBuilder();
    }
    private okhttp3.Call entitlementsBatchImportCall(Boolean strict, Boolean simulate, String _file, String description, OffsetDateTime referenceDate, ImportsEntitlementsBatchImportRequest importsEntitlementsBatchImportRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = importsEntitlementsBatchImportRequest;

        // create path and map variables
        String localVarPath = "/figgo/api/public/services/v1.0/leaveEntitlementsImport";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_file != null) {
            localVarFormParams.put("File", _file);
        }

        if (description != null) {
            localVarFormParams.put("Description", description);
        }

        if (referenceDate != null) {
            localVarFormParams.put("ReferenceDate", referenceDate);
        }

        if (strict != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("strict", strict));
        }

        if (simulate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("simulate", simulate));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call entitlementsBatchImportValidateBeforeCall(Boolean strict, Boolean simulate, String _file, String description, OffsetDateTime referenceDate, ImportsEntitlementsBatchImportRequest importsEntitlementsBatchImportRequest, final ApiCallback _callback) throws ApiException {
        return entitlementsBatchImportCall(strict, simulate, _file, description, referenceDate, importsEntitlementsBatchImportRequest, _callback);

    }


    private ApiResponse<ImportsEntitlementsBatchImportResponse> entitlementsBatchImportWithHttpInfo(Boolean strict, Boolean simulate, String _file, String description, OffsetDateTime referenceDate, ImportsEntitlementsBatchImportRequest importsEntitlementsBatchImportRequest) throws ApiException {
        okhttp3.Call localVarCall = entitlementsBatchImportValidateBeforeCall(strict, simulate, _file, description, referenceDate, importsEntitlementsBatchImportRequest, null);
        Type localVarReturnType = new TypeToken<ImportsEntitlementsBatchImportResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call entitlementsBatchImportAsync(Boolean strict, Boolean simulate, String _file, String description, OffsetDateTime referenceDate, ImportsEntitlementsBatchImportRequest importsEntitlementsBatchImportRequest, final ApiCallback<ImportsEntitlementsBatchImportResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = entitlementsBatchImportValidateBeforeCall(strict, simulate, _file, description, referenceDate, importsEntitlementsBatchImportRequest, _callback);
        Type localVarReturnType = new TypeToken<ImportsEntitlementsBatchImportResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class EntitlementsBatchImportRequestBuilder {
        private Boolean strict;
        private Boolean simulate;
        private String _file;
        private String description;
        private OffsetDateTime referenceDate;

        private EntitlementsBatchImportRequestBuilder() {
        }

        /**
         * Set strict
         * @param strict In strict mode, if the import has errors, nothing is imported. Without strict mode, the lines in error are ignored and those in success are imported. (optional, default to false)
         * @return EntitlementsBatchImportRequestBuilder
         */
        public EntitlementsBatchImportRequestBuilder strict(Boolean strict) {
            this.strict = strict;
            return this;
        }
        
        /**
         * Set simulate
         * @param simulate Allows you to simulate the import. In this case, the response indicates the theoretical result of the import without any data being recorded. (optional, default to false)
         * @return EntitlementsBatchImportRequestBuilder
         */
        public EntitlementsBatchImportRequestBuilder simulate(Boolean simulate) {
            this.simulate = simulate;
            return this;
        }
        
        /**
         * Set _file
         * @param _file  (optional)
         * @return EntitlementsBatchImportRequestBuilder
         */
        public EntitlementsBatchImportRequestBuilder _file(String _file) {
            this._file = _file;
            return this;
        }
        
        /**
         * Set description
         * @param description Description of the entries generated by the import (visible to users in the account details). (optional)
         * @return EntitlementsBatchImportRequestBuilder
         */
        public EntitlementsBatchImportRequestBuilder description(String description) {
            this.description = description;
            return this;
        }
        
        /**
         * Set referenceDate
         * @param referenceDate Reference date (text mode). Respect the format: yyyy-MM-ddThh: mm: ss (optional)
         * @return EntitlementsBatchImportRequestBuilder
         */
        public EntitlementsBatchImportRequestBuilder referenceDate(OffsetDateTime referenceDate) {
            this.referenceDate = referenceDate;
            return this;
        }
        
        /**
         * Build call for entitlementsBatchImport
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ImportsEntitlementsBatchImportRequest importsEntitlementsBatchImportRequest = buildBodyParams();
            return entitlementsBatchImportCall(strict, simulate, _file, description, referenceDate, importsEntitlementsBatchImportRequest, _callback);
        }

        private ImportsEntitlementsBatchImportRequest buildBodyParams() {
            ImportsEntitlementsBatchImportRequest importsEntitlementsBatchImportRequest = new ImportsEntitlementsBatchImportRequest();
            importsEntitlementsBatchImportRequest._file(this._file);
            importsEntitlementsBatchImportRequest.description(this.description);
            importsEntitlementsBatchImportRequest.referenceDate(this.referenceDate);
            return importsEntitlementsBatchImportRequest;
        }

        /**
         * Execute entitlementsBatchImport request
         * @return ImportsEntitlementsBatchImportResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ImportsEntitlementsBatchImportResponse execute() throws ApiException {
            ImportsEntitlementsBatchImportRequest importsEntitlementsBatchImportRequest = buildBodyParams();
            ApiResponse<ImportsEntitlementsBatchImportResponse> localVarResp = entitlementsBatchImportWithHttpInfo(strict, simulate, _file, description, referenceDate, importsEntitlementsBatchImportRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute entitlementsBatchImport request with HTTP info returned
         * @return ApiResponse&lt;ImportsEntitlementsBatchImportResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<ImportsEntitlementsBatchImportResponse> executeWithHttpInfo() throws ApiException {
            ImportsEntitlementsBatchImportRequest importsEntitlementsBatchImportRequest = buildBodyParams();
            return entitlementsBatchImportWithHttpInfo(strict, simulate, _file, description, referenceDate, importsEntitlementsBatchImportRequest);
        }

        /**
         * Execute entitlementsBatchImport request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<ImportsEntitlementsBatchImportResponse> _callback) throws ApiException {
            ImportsEntitlementsBatchImportRequest importsEntitlementsBatchImportRequest = buildBodyParams();
            return entitlementsBatchImportAsync(strict, simulate, _file, description, referenceDate, importsEntitlementsBatchImportRequest, _callback);
        }
    }

    /**
     * Import entitlements (deprecated)
     * **Supported file formats:** - CSV   - \&quot;UTF-8\&quot; encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit&gt; A group of collaborators&gt; File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the &#x60;globalErrors&#x60; field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the &#x60;lineErrors&#x60; field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the &#x60;globalErrors&#x60;: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the &#x60;lineErrors&#x60;: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
     * @return EntitlementsBatchImportRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public EntitlementsBatchImportRequestBuilder entitlementsBatchImport() throws IllegalArgumentException {
        return new EntitlementsBatchImportRequestBuilder();
    }
    private okhttp3.Call getProgressCall(String summaryId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/timmi-absences/api/imports/v1.0/leavePeriods/{summaryId}/progress"
            .replace("{" + "summaryId" + "}", localVarApiClient.escapeString(summaryId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getProgressValidateBeforeCall(String summaryId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'summaryId' is set
        if (summaryId == null) {
            throw new ApiException("Missing the required parameter 'summaryId' when calling getProgress(Async)");
        }

        return getProgressCall(summaryId, _callback);

    }


    private ApiResponse<Integer> getProgressWithHttpInfo(String summaryId) throws ApiException {
        okhttp3.Call localVarCall = getProgressValidateBeforeCall(summaryId, null);
        Type localVarReturnType = new TypeToken<Integer>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getProgressAsync(String summaryId, final ApiCallback<Integer> _callback) throws ApiException {

        okhttp3.Call localVarCall = getProgressValidateBeforeCall(summaryId, _callback);
        Type localVarReturnType = new TypeToken<Integer>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetProgressRequestBuilder {
        private final String summaryId;

        private GetProgressRequestBuilder(String summaryId) {
            this.summaryId = summaryId;
        }

        /**
         * Build call for getProgress
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getProgressCall(summaryId, _callback);
        }


        /**
         * Execute getProgress request
         * @return Integer
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public Integer execute() throws ApiException {
            ApiResponse<Integer> localVarResp = getProgressWithHttpInfo(summaryId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getProgress request with HTTP info returned
         * @return ApiResponse&lt;Integer&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Integer> executeWithHttpInfo() throws ApiException {
            return getProgressWithHttpInfo(summaryId);
        }

        /**
         * Execute getProgress request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Integer> _callback) throws ApiException {
            return getProgressAsync(summaryId, _callback);
        }
    }

    /**
     * Get import leaves progress
     * Retrieve the progress of Import leaves API request.
     * @param summaryId Identifier of the import (required)
     * @return GetProgressRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetProgressRequestBuilder getProgress(String summaryId) throws IllegalArgumentException {
        if (summaryId == null) throw new IllegalArgumentException("\"summaryId\" is required but got null");
            

        return new GetProgressRequestBuilder(summaryId);
    }
    private okhttp3.Call importLeaveEntitlementsCall(Boolean strict, Boolean simulate, String _file, String description, OffsetDateTime referenceDate, ImportsImportLeaveEntitlementsRequest importsImportLeaveEntitlementsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = importsImportLeaveEntitlementsRequest;

        // create path and map variables
        String localVarPath = "/timmi-absences/api/public/services/v1.0/leaveEntitlementsImport";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_file != null) {
            localVarFormParams.put("File", _file);
        }

        if (description != null) {
            localVarFormParams.put("Description", description);
        }

        if (referenceDate != null) {
            localVarFormParams.put("ReferenceDate", referenceDate);
        }

        if (strict != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("strict", strict));
        }

        if (simulate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("simulate", simulate));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call importLeaveEntitlementsValidateBeforeCall(Boolean strict, Boolean simulate, String _file, String description, OffsetDateTime referenceDate, ImportsImportLeaveEntitlementsRequest importsImportLeaveEntitlementsRequest, final ApiCallback _callback) throws ApiException {
        return importLeaveEntitlementsCall(strict, simulate, _file, description, referenceDate, importsImportLeaveEntitlementsRequest, _callback);

    }


    private ApiResponse<ImportsEntitlementsBatchImportResponse> importLeaveEntitlementsWithHttpInfo(Boolean strict, Boolean simulate, String _file, String description, OffsetDateTime referenceDate, ImportsImportLeaveEntitlementsRequest importsImportLeaveEntitlementsRequest) throws ApiException {
        okhttp3.Call localVarCall = importLeaveEntitlementsValidateBeforeCall(strict, simulate, _file, description, referenceDate, importsImportLeaveEntitlementsRequest, null);
        Type localVarReturnType = new TypeToken<ImportsEntitlementsBatchImportResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call importLeaveEntitlementsAsync(Boolean strict, Boolean simulate, String _file, String description, OffsetDateTime referenceDate, ImportsImportLeaveEntitlementsRequest importsImportLeaveEntitlementsRequest, final ApiCallback<ImportsEntitlementsBatchImportResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = importLeaveEntitlementsValidateBeforeCall(strict, simulate, _file, description, referenceDate, importsImportLeaveEntitlementsRequest, _callback);
        Type localVarReturnType = new TypeToken<ImportsEntitlementsBatchImportResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ImportLeaveEntitlementsRequestBuilder {
        private Boolean strict;
        private Boolean simulate;
        private String _file;
        private String description;
        private OffsetDateTime referenceDate;

        private ImportLeaveEntitlementsRequestBuilder() {
        }

        /**
         * Set strict
         * @param strict In strict mode, if the import has errors, nothing is imported. Without strict mode, the lines in error are ignored and those in success are imported. (optional, default to false)
         * @return ImportLeaveEntitlementsRequestBuilder
         */
        public ImportLeaveEntitlementsRequestBuilder strict(Boolean strict) {
            this.strict = strict;
            return this;
        }
        
        /**
         * Set simulate
         * @param simulate Allows you to simulate the import. In this case, the response indicates the theoretical result of the import without any data being recorded. (optional, default to false)
         * @return ImportLeaveEntitlementsRequestBuilder
         */
        public ImportLeaveEntitlementsRequestBuilder simulate(Boolean simulate) {
            this.simulate = simulate;
            return this;
        }
        
        /**
         * Set _file
         * @param _file  (optional)
         * @return ImportLeaveEntitlementsRequestBuilder
         */
        public ImportLeaveEntitlementsRequestBuilder _file(String _file) {
            this._file = _file;
            return this;
        }
        
        /**
         * Set description
         * @param description Description of the entries generated by the import (visible to users in the account details). (optional)
         * @return ImportLeaveEntitlementsRequestBuilder
         */
        public ImportLeaveEntitlementsRequestBuilder description(String description) {
            this.description = description;
            return this;
        }
        
        /**
         * Set referenceDate
         * @param referenceDate Reference date (text mode). Respect the format: yyyy-MM-ddThh: mm: ss (optional)
         * @return ImportLeaveEntitlementsRequestBuilder
         */
        public ImportLeaveEntitlementsRequestBuilder referenceDate(OffsetDateTime referenceDate) {
            this.referenceDate = referenceDate;
            return this;
        }
        
        /**
         * Build call for importLeaveEntitlements
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ImportsImportLeaveEntitlementsRequest importsImportLeaveEntitlementsRequest = buildBodyParams();
            return importLeaveEntitlementsCall(strict, simulate, _file, description, referenceDate, importsImportLeaveEntitlementsRequest, _callback);
        }

        private ImportsImportLeaveEntitlementsRequest buildBodyParams() {
            ImportsImportLeaveEntitlementsRequest importsImportLeaveEntitlementsRequest = new ImportsImportLeaveEntitlementsRequest();
            importsImportLeaveEntitlementsRequest._file(this._file);
            importsImportLeaveEntitlementsRequest.description(this.description);
            importsImportLeaveEntitlementsRequest.referenceDate(this.referenceDate);
            return importsImportLeaveEntitlementsRequest;
        }

        /**
         * Execute importLeaveEntitlements request
         * @return ImportsEntitlementsBatchImportResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
         </table>
         */
        public ImportsEntitlementsBatchImportResponse execute() throws ApiException {
            ImportsImportLeaveEntitlementsRequest importsImportLeaveEntitlementsRequest = buildBodyParams();
            ApiResponse<ImportsEntitlementsBatchImportResponse> localVarResp = importLeaveEntitlementsWithHttpInfo(strict, simulate, _file, description, referenceDate, importsImportLeaveEntitlementsRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute importLeaveEntitlements request with HTTP info returned
         * @return ApiResponse&lt;ImportsEntitlementsBatchImportResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ImportsEntitlementsBatchImportResponse> executeWithHttpInfo() throws ApiException {
            ImportsImportLeaveEntitlementsRequest importsImportLeaveEntitlementsRequest = buildBodyParams();
            return importLeaveEntitlementsWithHttpInfo(strict, simulate, _file, description, referenceDate, importsImportLeaveEntitlementsRequest);
        }

        /**
         * Execute importLeaveEntitlements request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ImportsEntitlementsBatchImportResponse> _callback) throws ApiException {
            ImportsImportLeaveEntitlementsRequest importsImportLeaveEntitlementsRequest = buildBodyParams();
            return importLeaveEntitlementsAsync(strict, simulate, _file, description, referenceDate, importsImportLeaveEntitlementsRequest, _callback);
        }
    }

    /**
     * Import entitlements
     * **Supported file formats:** - CSV   - \&quot;UTF-8\&quot; encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit&gt; A group of collaborators&gt; File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the &#x60;globalErrors&#x60; field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the &#x60;lineErrors&#x60; field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the &#x60;globalErrors&#x60;: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the &#x60;lineErrors&#x60;: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
     * @return ImportLeaveEntitlementsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
     </table>
     */
    public ImportLeaveEntitlementsRequestBuilder importLeaveEntitlements() throws IllegalArgumentException {
        return new ImportLeaveEntitlementsRequestBuilder();
    }
    private okhttp3.Call replaceEntitlementsCall(Boolean strict, Boolean simulate, String _file, String description, OffsetDateTime referenceDate, String entryTypes, ImportsReplaceEntitlementsRequest importsReplaceEntitlementsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = importsReplaceEntitlementsRequest;

        // create path and map variables
        String localVarPath = "/figgo/api/public/services/v1.0/leaveEntitlementsReplace";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_file != null) {
            localVarFormParams.put("File", _file);
        }

        if (description != null) {
            localVarFormParams.put("Description", description);
        }

        if (referenceDate != null) {
            localVarFormParams.put("ReferenceDate", referenceDate);
        }

        if (entryTypes != null) {
            localVarFormParams.put("EntryTypes", entryTypes);
        }

        if (strict != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("strict", strict));
        }

        if (simulate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("simulate", simulate));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call replaceEntitlementsValidateBeforeCall(Boolean strict, Boolean simulate, String _file, String description, OffsetDateTime referenceDate, String entryTypes, ImportsReplaceEntitlementsRequest importsReplaceEntitlementsRequest, final ApiCallback _callback) throws ApiException {
        return replaceEntitlementsCall(strict, simulate, _file, description, referenceDate, entryTypes, importsReplaceEntitlementsRequest, _callback);

    }


    private ApiResponse<ImportsEntitlementsBatchImportResponse> replaceEntitlementsWithHttpInfo(Boolean strict, Boolean simulate, String _file, String description, OffsetDateTime referenceDate, String entryTypes, ImportsReplaceEntitlementsRequest importsReplaceEntitlementsRequest) throws ApiException {
        okhttp3.Call localVarCall = replaceEntitlementsValidateBeforeCall(strict, simulate, _file, description, referenceDate, entryTypes, importsReplaceEntitlementsRequest, null);
        Type localVarReturnType = new TypeToken<ImportsEntitlementsBatchImportResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call replaceEntitlementsAsync(Boolean strict, Boolean simulate, String _file, String description, OffsetDateTime referenceDate, String entryTypes, ImportsReplaceEntitlementsRequest importsReplaceEntitlementsRequest, final ApiCallback<ImportsEntitlementsBatchImportResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = replaceEntitlementsValidateBeforeCall(strict, simulate, _file, description, referenceDate, entryTypes, importsReplaceEntitlementsRequest, _callback);
        Type localVarReturnType = new TypeToken<ImportsEntitlementsBatchImportResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ReplaceEntitlementsRequestBuilder {
        private Boolean strict;
        private Boolean simulate;
        private String _file;
        private String description;
        private OffsetDateTime referenceDate;
        private String entryTypes;

        private ReplaceEntitlementsRequestBuilder() {
        }

        /**
         * Set strict
         * @param strict In strict mode, if the import has errors, nothing is imported. Without strict mode, the lines in error are ignored and those in success are imported. (optional, default to false)
         * @return ReplaceEntitlementsRequestBuilder
         */
        public ReplaceEntitlementsRequestBuilder strict(Boolean strict) {
            this.strict = strict;
            return this;
        }
        
        /**
         * Set simulate
         * @param simulate Allows you to simulate the import. In this case, the response indicates the theoretical result of the import without any data being recorded. (optional, default to false)
         * @return ReplaceEntitlementsRequestBuilder
         */
        public ReplaceEntitlementsRequestBuilder simulate(Boolean simulate) {
            this.simulate = simulate;
            return this;
        }
        
        /**
         * Set _file
         * @param _file  (optional)
         * @return ReplaceEntitlementsRequestBuilder
         */
        public ReplaceEntitlementsRequestBuilder _file(String _file) {
            this._file = _file;
            return this;
        }
        
        /**
         * Set description
         * @param description Description of the entries generated by the import (visible to users in the account details). (optional)
         * @return ReplaceEntitlementsRequestBuilder
         */
        public ReplaceEntitlementsRequestBuilder description(String description) {
            this.description = description;
            return this;
        }
        
        /**
         * Set referenceDate
         * @param referenceDate Reference date (text mode). Respect the format: yyyy-MM-ddThh: mm: ss (optional)
         * @return ReplaceEntitlementsRequestBuilder
         */
        public ReplaceEntitlementsRequestBuilder referenceDate(OffsetDateTime referenceDate) {
            this.referenceDate = referenceDate;
            return this;
        }
        
        /**
         * Set entryTypes
         * @param entryTypes Types of entries to take into account, separated by commas, from the following list: AutoAccruals, ManualAccruals, Regularisations, EntitlementsImport, Seniority, Fractionnement, TimeSavings, Comp  By default: &#x60;AutoAccruals, ManualAccruals, Regularizations&#x60; which correspond to the main cases of acquisition (automatic acquisition, manual adjustments, regularisations). (optional, default to AutoAccruals,ManualAccruals,Regularizations)
         * @return ReplaceEntitlementsRequestBuilder
         */
        public ReplaceEntitlementsRequestBuilder entryTypes(String entryTypes) {
            this.entryTypes = entryTypes;
            return this;
        }
        
        /**
         * Build call for replaceEntitlements
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ImportsReplaceEntitlementsRequest importsReplaceEntitlementsRequest = buildBodyParams();
            return replaceEntitlementsCall(strict, simulate, _file, description, referenceDate, entryTypes, importsReplaceEntitlementsRequest, _callback);
        }

        private ImportsReplaceEntitlementsRequest buildBodyParams() {
            ImportsReplaceEntitlementsRequest importsReplaceEntitlementsRequest = new ImportsReplaceEntitlementsRequest();
            importsReplaceEntitlementsRequest._file(this._file);
            importsReplaceEntitlementsRequest.description(this.description);
            importsReplaceEntitlementsRequest.referenceDate(this.referenceDate);
            importsReplaceEntitlementsRequest.entryTypes(this.entryTypes);
            return importsReplaceEntitlementsRequest;
        }

        /**
         * Execute replaceEntitlements request
         * @return ImportsEntitlementsBatchImportResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ImportsEntitlementsBatchImportResponse execute() throws ApiException {
            ImportsReplaceEntitlementsRequest importsReplaceEntitlementsRequest = buildBodyParams();
            ApiResponse<ImportsEntitlementsBatchImportResponse> localVarResp = replaceEntitlementsWithHttpInfo(strict, simulate, _file, description, referenceDate, entryTypes, importsReplaceEntitlementsRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute replaceEntitlements request with HTTP info returned
         * @return ApiResponse&lt;ImportsEntitlementsBatchImportResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<ImportsEntitlementsBatchImportResponse> executeWithHttpInfo() throws ApiException {
            ImportsReplaceEntitlementsRequest importsReplaceEntitlementsRequest = buildBodyParams();
            return replaceEntitlementsWithHttpInfo(strict, simulate, _file, description, referenceDate, entryTypes, importsReplaceEntitlementsRequest);
        }

        /**
         * Execute replaceEntitlements request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<ImportsEntitlementsBatchImportResponse> _callback) throws ApiException {
            ImportsReplaceEntitlementsRequest importsReplaceEntitlementsRequest = buildBodyParams();
            return replaceEntitlementsAsync(strict, simulate, _file, description, referenceDate, entryTypes, importsReplaceEntitlementsRequest, _callback);
        }
    }

    /**
     * Replace entitlements (deprecated)
     * **Supported file formats:** - CSV   - \&quot;UTF-8\&quot; encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit&gt; A group of collaborators&gt; File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the &#x60;globalErrors&#x60; field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the &#x60;lineErrors&#x60; field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the &#x60;globalErrors&#x60;: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the &#x60;lineErrors&#x60;: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
     * @return ReplaceEntitlementsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public ReplaceEntitlementsRequestBuilder replaceEntitlements() throws IllegalArgumentException {
        return new ReplaceEntitlementsRequestBuilder();
    }
    private okhttp3.Call replaceEntitlements_0Call(Boolean strict, Boolean simulate, String _file, String description, OffsetDateTime referenceDate, String entryTypes, ImportsReplaceEntitlementsRequest1 importsReplaceEntitlementsRequest1, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = importsReplaceEntitlementsRequest1;

        // create path and map variables
        String localVarPath = "/timmi-absences/api/public/services/v1.0/leaveEntitlementsReplace";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_file != null) {
            localVarFormParams.put("File", _file);
        }

        if (description != null) {
            localVarFormParams.put("Description", description);
        }

        if (referenceDate != null) {
            localVarFormParams.put("ReferenceDate", referenceDate);
        }

        if (entryTypes != null) {
            localVarFormParams.put("EntryTypes", entryTypes);
        }

        if (strict != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("strict", strict));
        }

        if (simulate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("simulate", simulate));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call replaceEntitlements_0ValidateBeforeCall(Boolean strict, Boolean simulate, String _file, String description, OffsetDateTime referenceDate, String entryTypes, ImportsReplaceEntitlementsRequest1 importsReplaceEntitlementsRequest1, final ApiCallback _callback) throws ApiException {
        return replaceEntitlements_0Call(strict, simulate, _file, description, referenceDate, entryTypes, importsReplaceEntitlementsRequest1, _callback);

    }


    private ApiResponse<ImportsEntitlementsBatchImportResponse> replaceEntitlements_0WithHttpInfo(Boolean strict, Boolean simulate, String _file, String description, OffsetDateTime referenceDate, String entryTypes, ImportsReplaceEntitlementsRequest1 importsReplaceEntitlementsRequest1) throws ApiException {
        okhttp3.Call localVarCall = replaceEntitlements_0ValidateBeforeCall(strict, simulate, _file, description, referenceDate, entryTypes, importsReplaceEntitlementsRequest1, null);
        Type localVarReturnType = new TypeToken<ImportsEntitlementsBatchImportResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call replaceEntitlements_0Async(Boolean strict, Boolean simulate, String _file, String description, OffsetDateTime referenceDate, String entryTypes, ImportsReplaceEntitlementsRequest1 importsReplaceEntitlementsRequest1, final ApiCallback<ImportsEntitlementsBatchImportResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = replaceEntitlements_0ValidateBeforeCall(strict, simulate, _file, description, referenceDate, entryTypes, importsReplaceEntitlementsRequest1, _callback);
        Type localVarReturnType = new TypeToken<ImportsEntitlementsBatchImportResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ReplaceEntitlements0RequestBuilder {
        private Boolean strict;
        private Boolean simulate;
        private String _file;
        private String description;
        private OffsetDateTime referenceDate;
        private String entryTypes;

        private ReplaceEntitlements0RequestBuilder() {
        }

        /**
         * Set strict
         * @param strict In strict mode, if the import has errors, nothing is imported. Without strict mode, the lines in error are ignored and those in success are imported. (optional, default to false)
         * @return ReplaceEntitlements0RequestBuilder
         */
        public ReplaceEntitlements0RequestBuilder strict(Boolean strict) {
            this.strict = strict;
            return this;
        }
        
        /**
         * Set simulate
         * @param simulate Allows you to simulate the import. In this case, the response indicates the theoretical result of the import without any data being recorded. (optional, default to false)
         * @return ReplaceEntitlements0RequestBuilder
         */
        public ReplaceEntitlements0RequestBuilder simulate(Boolean simulate) {
            this.simulate = simulate;
            return this;
        }
        
        /**
         * Set _file
         * @param _file  (optional)
         * @return ReplaceEntitlements0RequestBuilder
         */
        public ReplaceEntitlements0RequestBuilder _file(String _file) {
            this._file = _file;
            return this;
        }
        
        /**
         * Set description
         * @param description Description of the entries generated by the import (visible to users in the account details). (optional)
         * @return ReplaceEntitlements0RequestBuilder
         */
        public ReplaceEntitlements0RequestBuilder description(String description) {
            this.description = description;
            return this;
        }
        
        /**
         * Set referenceDate
         * @param referenceDate Reference date (text mode). Respect the format: yyyy-MM-ddThh: mm: ss (optional)
         * @return ReplaceEntitlements0RequestBuilder
         */
        public ReplaceEntitlements0RequestBuilder referenceDate(OffsetDateTime referenceDate) {
            this.referenceDate = referenceDate;
            return this;
        }
        
        /**
         * Set entryTypes
         * @param entryTypes Types of entries to take into account, separated by commas, from the following list: AutoAccruals, ManualAccruals, Regularisations, EntitlementsImport, Seniority, Fractionnement, TimeSavings, Comp  By default: &#x60;AutoAccruals, ManualAccruals, Regularizations&#x60; which correspond to the main cases of acquisition (automatic acquisition, manual adjustments, regularisations). (optional, default to AutoAccruals,ManualAccruals,Regularizations)
         * @return ReplaceEntitlements0RequestBuilder
         */
        public ReplaceEntitlements0RequestBuilder entryTypes(String entryTypes) {
            this.entryTypes = entryTypes;
            return this;
        }
        
        /**
         * Build call for replaceEntitlements_0
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ImportsReplaceEntitlementsRequest1 importsReplaceEntitlementsRequest1 = buildBodyParams();
            return replaceEntitlements_0Call(strict, simulate, _file, description, referenceDate, entryTypes, importsReplaceEntitlementsRequest1, _callback);
        }

        private ImportsReplaceEntitlementsRequest1 buildBodyParams() {
            ImportsReplaceEntitlementsRequest1 importsReplaceEntitlementsRequest1 = new ImportsReplaceEntitlementsRequest1();
            importsReplaceEntitlementsRequest1._file(this._file);
            importsReplaceEntitlementsRequest1.description(this.description);
            importsReplaceEntitlementsRequest1.referenceDate(this.referenceDate);
            importsReplaceEntitlementsRequest1.entryTypes(this.entryTypes);
            return importsReplaceEntitlementsRequest1;
        }

        /**
         * Execute replaceEntitlements_0 request
         * @return ImportsEntitlementsBatchImportResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
         </table>
         */
        public ImportsEntitlementsBatchImportResponse execute() throws ApiException {
            ImportsReplaceEntitlementsRequest1 importsReplaceEntitlementsRequest1 = buildBodyParams();
            ApiResponse<ImportsEntitlementsBatchImportResponse> localVarResp = replaceEntitlements_0WithHttpInfo(strict, simulate, _file, description, referenceDate, entryTypes, importsReplaceEntitlementsRequest1);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute replaceEntitlements_0 request with HTTP info returned
         * @return ApiResponse&lt;ImportsEntitlementsBatchImportResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ImportsEntitlementsBatchImportResponse> executeWithHttpInfo() throws ApiException {
            ImportsReplaceEntitlementsRequest1 importsReplaceEntitlementsRequest1 = buildBodyParams();
            return replaceEntitlements_0WithHttpInfo(strict, simulate, _file, description, referenceDate, entryTypes, importsReplaceEntitlementsRequest1);
        }

        /**
         * Execute replaceEntitlements_0 request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ImportsEntitlementsBatchImportResponse> _callback) throws ApiException {
            ImportsReplaceEntitlementsRequest1 importsReplaceEntitlementsRequest1 = buildBodyParams();
            return replaceEntitlements_0Async(strict, simulate, _file, description, referenceDate, entryTypes, importsReplaceEntitlementsRequest1, _callback);
        }
    }

    /**
     * Replace entitlements
     * **Supported file formats:** - CSV   - \&quot;UTF-8\&quot; encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit&gt; A group of collaborators&gt; File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the &#x60;globalErrors&#x60; field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the &#x60;lineErrors&#x60; field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the &#x60;globalErrors&#x60;: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the &#x60;lineErrors&#x60;: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
     * @return ReplaceEntitlements0RequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Example response </td><td>  -  </td></tr>
     </table>
     */
    public ReplaceEntitlements0RequestBuilder replaceEntitlements_0() throws IllegalArgumentException {
        return new ReplaceEntitlements0RequestBuilder();
    }
}
